<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Design Kiosk Page</title>
  <link href="https://fonts.googleapis.com/css2?family=Indie+Flower&family=Permanent+Marker&family=Caveat&family=Dancing+Script&display=swap" rel="stylesheet">
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    html, body { height:100%; font-family: -apple-system, sans-serif; background:#f8f9fa; }
    .container {
      display:flex; flex-direction:column; height:100vh;
      padding: max(1rem, env(safe-area-inset-top)) 1rem max(1rem, env(safe-area-inset-bottom));
      gap:1rem;
    }
    h1 { font-size:1.6rem; text-align:center; color:#333; }
    .section {
      background:white; padding:1rem; border-radius:12px; box-shadow:0 2px 8px rgba(0,0,0,0.1);
    }
    label { display:block; margin:0.5rem 0 0.3rem; font-weight:600; color:#444; }
    select, input[type="file"] {
      width:100%; padding:0.8rem; font-size:1rem; border:2px solid #ddd; border-radius:8px;
    }
    .bg-grid {
      display:grid; grid-template-columns:repeat(3,1fr); gap:0.5rem; margin-top:0.5rem;
    }
    .bg-thumb {
      width:100%; height:80px; object-fit:cover; border-radius:8px; cursor:pointer;
      border:3px solid transparent; transition:border 0.2s;
    }
    .bg-thumb.selected { border-color:#007bff; }
    .preview-img {
      width:100%; height:180px; object-fit:cover; border-radius:8px; margin-top:0.5rem;
      border:2px dashed #ccc; display:none;
    }
    .actions { display:flex; gap:1rem; }
    button {
      flex:1; padding:1rem; font-size:1.1rem; font-weight:600; color:white;
      background:#007bff; border:none; border-radius:12px; cursor:pointer;
    }
    button:active { background:#0056b3; }
    button.secondary { background:#6c757d; }
    button.secondary:active { background:#5a6268; }
    .status { text-align:center; font-size:0.9rem; color:#666; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Design Kiosk Page</h1>

    <div class="section">
      <label>1. Background Image</label>
      <div id="bg-grid" class="bg-grid"></div>
      <label style="margin-top:1rem">Or Upload New Image:</label>
      <input type="file" id="upload" accept="image/*" />
      <img id="preview" class="preview-img" src="" />
    </div>

    <div class="section">
      <label>2. Font Style</label>
      <select id="font">
        <!-- Populated dynamically from config.json availableFonts -->
      </select>
    </div>

    <div class="actions">
      <button onclick="saveDesign()">Save & Update Kiosk</button>
      <button class="secondary" onclick="location.reload()">Cancel</button>
    </div>
    <div class="status" id="status"></div>
    <!-- Toast notification (mobile friendly) -->
    <div id="toast" class="toast" aria-live="polite" role="status" style="display:none"></div>
  </div>

  <script>
    const bgGrid = document.getElementById('bg-grid');
    const upload = document.getElementById('upload');
    const preview = document.getElementById('preview');
    const fontSelect = document.getElementById('font');
    const status = document.getElementById('status');

  let backgrounds = [];        // Filled from server
  let selectedBg = null;       // Filename or 'uploaded'
  let uploadedDataUrl = null;
  let uploadedFileName = null; // original filename from file input

    // === 1. Load existing images from /bg/ ===
    function loadBackgrounds() {
      fetch('bg/index.php')
        .then(r => r.json())
        .then(files => {
          backgrounds = files;
          renderThumbs();
          loadConfig();
        })
        .catch(err => {
          console.error(err);
          status.textContent = 'Warning: Could not load backgrounds.';
          backgrounds = [];
          renderThumbs();
          loadConfig();
        });
    }

    // === 2. Render thumbnails ===
    function renderThumbs() {
      bgGrid.innerHTML = '';
      backgrounds.forEach(file => {
        const img = document.createElement('img');
        img.src = 'bg/' + file;
        img.className = 'bg-thumb';
        img.dataset.file = file;
        if (file === selectedBg) img.classList.add('selected');
        img.onclick = () => selectBg(file, img);
        bgGrid.appendChild(img);
      });
    }

    function selectBg(file, thumb) {
      selectedBg = file;
      uploadedDataUrl = null;
      preview.style.display = 'none';
      document.querySelectorAll('.bg-thumb').forEach(t => t.classList.remove('selected'));
      thumb.classList.add('selected');
    }

    // === 3. Handle file upload (preview only) ===
    upload.onchange = () => {
      const file = upload.files[0];
      if (!file) return;
      uploadedFileName = file.name || 'upload.jpg';
      const reader = new FileReader();
      reader.onload = e => {
        uploadedDataUrl = e.target.result;
        preview.src = uploadedDataUrl;
        preview.style.display = 'block';
        selectedBg = 'uploaded';
        document.querySelectorAll('.bg-thumb').forEach(t => t.classList.remove('selected'));
      };
      reader.readAsDataURL(file);
    };

    // === 4. Load saved config and populate fonts ===
    function loadConfig() {
      fetch('config.json')
        .then(r => r.ok ? r.json() : {})
        .then(cfg => {
          // Populate font dropdown from config.availableFonts
          if (cfg.availableFonts && typeof cfg.availableFonts === 'object') {
            fontSelect.innerHTML = '';
            Object.entries(cfg.availableFonts).forEach(([name, value]) => {
              const option = document.createElement('option');
              option.value = value;
              option.textContent = name;
              fontSelect.appendChild(option);
            });
            console.log('Fonts loaded from config:', Object.keys(cfg.availableFonts));
          } else {
            console.warn('No availableFonts in config.json');
          }
          
          if (cfg.bg) {
            if (cfg.bg.startsWith('data:')) {
              // Uploaded image
              selectedBg = 'uploaded';
              uploadedDataUrl = cfg.bg;
              preview.src = uploadedDataUrl;
              preview.style.display = 'block';
            } else {
              selectedBg = cfg.bg;
              const thumb = document.querySelector(`.bg-thumb[data-file="${cfg.bg}"]`);
              if (thumb) thumb.classList.add('selected');
            }
          }
          
          // Set the selected font after options are populated
          if (cfg.font) {
            fontSelect.value = cfg.font;
            console.log('Font set to:', cfg.font);
          }
        })
        .catch(err => {
          console.error('Failed to load config:', err);
          // Provide fallback fonts if config fails
          fontSelect.innerHTML = '<option value="Arial, sans-serif">Arial</option>' +
                                 '<option value="Georgia, serif">Georgia</option>' +
                                 '<option value="\'Comic Sans MS\', cursive">Comic Sans</option>';
        });
    }

    // === 5. Save design ===
    function saveDesign() {
      if (!selectedBg) {
        status.textContent = 'Please select a background.';
        return;
      }

      // Disable actions while saving
      const saveBtn = document.querySelector('.actions button');
      const cancelBtn = document.querySelector('.actions button.secondary');
      if (saveBtn) saveBtn.disabled = true;
      if (cancelBtn) cancelBtn.disabled = true;

      status.textContent = 'Saving...';

      const config = {
        bg: selectedBg === 'uploaded' ? uploadedDataUrl : selectedBg,
        font: fontSelect.value
      };

      // Save config.json
      fetch('config.json', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(config)
      })
      .then(r => {
        if (!r.ok) return r.text().then(t => Promise.reject('Config save failed: ' + (t || r.statusText)));
        return uploadImageIfNeeded();
      })
      .then(() => generateIndexHTML())
      .then(() => {
        status.textContent = 'Saved! Kiosk updated.';
        // Show mobile-friendly toast as confirmation
        if (window.showToast) showToast('Saved â€” kiosk updated');
        setTimeout(() => status.textContent = '', 3000);
      })
      .catch(err => {
        console.error('Save error:', err);
        status.textContent = 'Error: ' + (err && err.message ? err.message : err);
      })
      .finally(() => {
        if (saveBtn) saveBtn.disabled = false;
        if (cancelBtn) cancelBtn.disabled = false;
      });
    }

    // === 6. Upload new image via PHP ===
    function uploadImageIfNeeded() {
      if (selectedBg !== 'uploaded' || !uploadedDataUrl) return Promise.resolve();

      // Convert dataURL to Blob (use helper) to preserve MIME and avoid
      // potential CORS issues fetching data: URLs.
      const blob = dataURLtoBlob(uploadedDataUrl);
      const form = new FormData();
      // Use original filename when available
      const name = uploadedFileName || 'upload.jpg';
      form.append('image', blob, name);

      return fetch('upload-bg.php', {
        method: 'POST',
        body: form
      })
      .then(r => {
        // Try to parse JSON even on non-OK to surface server-side messages
        return r.text().then(text => {
          let data = null;
          try { data = text ? JSON.parse(text) : null; } catch(e) { /* ignore */ }
          if (!r.ok) {
            const errMsg = data && (data.error || data.detail) ? (data.error + (data.detail ? (': ' + data.detail) : '')) : (text || r.statusText);
            return Promise.reject(errMsg);
          }
          return data;
        });
      })
      .then(data => {
        if (data && data.filename) {
          selectedBg = data.filename;
          backgrounds.push(data.filename);
          renderThumbs();
          const thumb = document.querySelector(`.bg-thumb[data-file="${data.filename}"]`);
          if (thumb) thumb.classList.add('selected');
          return updateConfigWithNewFilename(data.filename);
        }
        const err = data && (data.error || data.detail) ? (data.error + (data.detail ? (': ' + data.detail) : '')) : 'Upload failed (no filename returned)';
        return Promise.reject(err);
      })
      .catch(err => {
        console.error('Upload error:', err);
        // Surface server-side error to user
        status.textContent = 'Upload error: ' + (err && err.message ? err.message : err);
        return Promise.reject(err);
      });
    }

    function updateConfigWithNewFilename(filename) {
      return fetch('config.json')
        .then(r => r.ok ? r.json() : {})
        .then(cfg => {
          cfg.bg = filename;
          return fetch('config.json', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(cfg)
          }).then(r => {
            if (!r.ok) return Promise.reject('Failed to update config with filename');
            return r;
          });
        });
    }

    function dataURLtoBlob(dataurl) {
      const [meta, base64] = dataurl.split(',');
      const mime = meta.match(/:(.*?);/)[1];
      const bstr = atob(base64);
      let n = bstr.length;
      const u8arr = new Uint8Array(n);
      while (n--) u8arr[n] = bstr.charCodeAt(n);
      return new Blob([u8arr], { type: mime });
    }

    // === 7. Generate index.html ===
    function generateIndexHTML() {
      const bgUrl = selectedBg === 'uploaded' ? uploadedDataUrl : 'bg/' + selectedBg;
      const font = fontSelect.value;

      // Escape double quotes in bgUrl for safe insertion into url("...")
      const safeBg = String(bgUrl).replace(/"/g, '\\"');

      var html = '';
      html += '<!DOCTYPE html>\n';
      html += '<html lang="en">\n';
      html += '<head>\n';
      html += '  <meta charset="UTF-8" />\n';
      html += '  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>\n';
      html += '  <title>Daily Specials</title>\n';
      html += '  <style>\n';
      html += '    * { margin:0; padding:0; box-sizing:border-box; }\n';
      html += '    body, html { height:100%; overflow:hidden; }\n';
      html += '    body {\n';
      html += '      background: url("' + safeBg + '") center/cover no-repeat;\n';
      html += '      font-family: ' + font + ';\n';
      html += '      color: white;\n';
      html += '      text-shadow: 2px 2px 4px rgba(0,0,0,0.7);\n';
      html += '      display: flex;\n';
      html += '      flex-direction: column;\n';
      html += '    }\n';
      html += '    header {\n';
      html += '      background: rgba(0,0,0,0.5);\n';
      html += '      padding: 1rem;\n';
      html += '      text-align: center;\n';
      html += '      font-size: 2.5rem;\n';
      html += '      font-weight: bold;\n';
      html += '    }\n';
      html += '    #specials {\n';
      html += '      flex: 1;\n';
      html += '      padding: 2rem;\n';
      html += '      font-size: 1.8rem;\n';
      html += '      line-height: 1.6;\n';
      html += '      overflow-y: auto;\n';
      html += '      white-space: pre-wrap;\n';
      html += '    }\n';
      html += '  </style>\n';
      html += '</head>\n';
      html += '<body>\n';
      html += '  <header>Specials</header>\n';
      html += '  <div id="specials"></div>\n';
      html += '  <script>\n';
      html += '    fetch(\'specials.txt?\' + Date.now())\n';
      html += '      .then(r => r.text())\n';
      html += '      .then(t => document.getElementById(\'specials\').textContent = t);\n';
      html += '    setInterval(() => location.reload(), 10000);\n';
      html += '  <\/script>\n';
      html += '</body>\n';
      html += '</html>\n';

      return fetch('index.html', {
        method: 'PUT',
        headers: { 'Content-Type': 'text/html' },
        body: html
      });
    }

    // === Start ===
    // Load backgrounds and then config (which populates fonts)
    loadBackgrounds();
    
    // Also load fonts immediately as a backup to ensure they're available
    setTimeout(() => {
      fetch('config.json')
        .then(r => r.ok ? r.json() : {})
        .then(cfg => {
          if (cfg.availableFonts && fontSelect.children.length === 0) {
            Object.entries(cfg.availableFonts).forEach(([name, value]) => {
              const option = document.createElement('option');
              option.value = value;
              option.textContent = name;
              fontSelect.appendChild(option);
            });
            if (cfg.font) fontSelect.value = cfg.font;
          }
        })
        .catch(err => console.error('Fallback font load failed:', err));
    }, 100);

    // === Toast helper ===
    (function(){
      // Create styles for toast
      const css = `
      .toast {
        position: fixed;
        left: 50%;
        bottom: max(1.25rem, env(safe-area-inset-bottom));
        transform: translateX(-50%);
        background: rgba(0,0,0,0.85);
        color: #fff;
        padding: 0.75rem 1rem;
        border-radius: 10px;
        font-size: 1rem;
        min-width: 160px;
        max-width: 92%;
        text-align: center;
        z-index: 9999;
        box-shadow: 0 6px 18px rgba(0,0,0,0.25);
        -webkit-backdrop-filter: blur(6px);
        backdrop-filter: blur(6px);
      }
      @media (prefers-reduced-motion: no-preference) {
        .toast.show { animation: toast-in 240ms ease-out; }
      }
      @keyframes toast-in { from { transform: translateX(-50%) translateY(8px); opacity: 0 } to { transform: translateX(-50%) translateY(0); opacity: 1 }}
      `;
      const s = document.createElement('style'); s.textContent = css; document.head.appendChild(s);

      let toastTimer = null;
      window.showToast = function(msg, ms=3000) {
        const el = document.getElementById('toast');
        if (!el) return;
        el.textContent = msg;
        el.style.display = 'block';
        el.classList.add('show');
        if (toastTimer) clearTimeout(toastTimer);
        toastTimer = setTimeout(() => {
          el.classList.remove('show');
          el.style.display = 'none';
        }, ms);
      };
    })();
  </script>
</body>
</html>